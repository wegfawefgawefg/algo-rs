use std::ffi::OsStr;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn is_rust_ident(s: &str) -> bool {
    let mut chars = s.chars();
    let Some(first) = chars.next() else {
        return false;
    };
    if !(first == '_' || first.is_ascii_alphabetic()) {
        return false;
    }
    chars.all(|c| c == '_' || c.is_ascii_alphanumeric())
}

fn main() {
    let algos_dir = PathBuf::from("src/algos");
    println!("cargo:rerun-if-changed={}", algos_dir.display());

    let mut algo_mods: Vec<String> = vec![];

    let entries = match fs::read_dir(&algos_dir) {
        Ok(e) => e,
        Err(err) => {
            // If the folder doesn't exist, still generate an empty registry so the crate builds.
            eprintln!("warning: unable to read {}: {}", algos_dir.display(), err);
            let out_dir = PathBuf::from(std::env::var_os("OUT_DIR").expect("OUT_DIR must be set"));
            let out_file = out_dir.join("algos_registry.rs");
            write_registry(&out_file, &algo_mods).expect("write registry");
            return;
        }
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension() != Some(OsStr::new("rs")) {
            continue;
        }
        if path.file_name() == Some(OsStr::new("mod.rs")) {
            continue;
        }

        println!("cargo:rerun-if-changed={}", path.display());

        let Some(stem) = path.file_stem().and_then(|s| s.to_str()) else {
            continue;
        };

        if !is_rust_ident(stem) {
            // Keep build strict: filenames become module names.
            panic!("algo file stem is not a valid Rust identifier: {}", stem);
        }

        // Allow "private" algos by prefixing with "_" (still compiled if referenced elsewhere,
        // but excluded from the runner registry).
        if stem.starts_with('_') {
            continue;
        }

        algo_mods.push(stem.to_string());
    }

    algo_mods.sort();
    algo_mods.dedup();

    let out_dir = PathBuf::from(std::env::var_os("OUT_DIR").expect("OUT_DIR must be set"));
    let out_file = out_dir.join("algos_registry.rs");
    write_registry(&out_file, &algo_mods).expect("write registry");
}

fn write_registry(out_file: &Path, algo_mods: &[String]) -> std::io::Result<()> {
    let mut f = fs::File::create(out_file)?;
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR must be set");

    writeln!(f, "// @generated by build.rs; do not edit by hand.")?;
    writeln!(f)?;

    for m in algo_mods {
        // `include!` expands from OUT_DIR, so `mod foo;` would try to load foo.rs from OUT_DIR.
        // Use an explicit path to the real source file instead.
        writeln!(
            f,
            "#[path = \"{}/src/algos/{}.rs\"] pub mod {};",
            manifest_dir, m, m
        )?;
    }

    writeln!(f)?;
    writeln!(f, "pub fn list() -> &'static [&'static str] {{")?;
    writeln!(f, "    &[")?;
    for m in algo_mods {
        writeln!(f, "        \"{}\",", m)?;
    }
    writeln!(f, "    ]")?;
    writeln!(f, "}}")?;

    writeln!(f)?;
    writeln!(
        f,
        "pub fn dispatch(name: &str, args: &[String]) -> Result<(), String> {{"
    )?;
    writeln!(f, "    match name {{")?;
    for m in algo_mods {
        writeln!(f, "        \"{0}\" => self::{0}::run(args),", m)?;
    }
    writeln!(
        f,
        "        _ => Err(format!(\"unknown algo: {{}}\", name)),"
    )?;
    writeln!(f, "    }}")?;
    writeln!(f, "}}")?;

    Ok(())
}
